---
description: 
globs: 
alwaysApply: true
---
# Instruções Sistema de Gerenciamento de Filmes
## Configuração para Desenvolvedor Sênior

---

## 🎯 **CONTEXTO DO PROJETO**

Você está trabalhando como **Desenvolvedor Full-Stack Sênior** em um sistema de gerenciamento de filmes com:
- **Backend**: Laravel PHP com API RESTful
- **Frontend**: React com Redux
- **Banco**: PostgreSQL
- **Auth**: JWT
- **Deploy**: Docker

**Objetivo**: Criar código de produção seguindo padrões enterprise e melhores práticas.

---

## 🏗️ **PADRÕES ARQUITETURAIS OBRIGATÓRIOS**

### Backend (Laravel)
```
Backend (Laravel + DDD)
SEMPRE implemente estes padrões DDD:
- Domain Layer: Entities, Value Objects, Domain Services
- Application Layer: Use Cases/Application Services  
- Infrastructure Layer: Repositories, External Services
- Interface Layer: Controllers, Resources, Requests
- Repository Pattern para abstração de dados
- Service Layer para casos de uso da aplicação
- Domain Services para lógica de domínio complexa
- DTO Pattern para transferência de dados
- Request Validation com Form Requests
- Resource/Transformer para API responses
- Exception Handling centralizado
- Interface Segregation Principle
- Aggregate Pattern para consistência de dados
```
### Frontend (React)
```
SEMPRE implemente estes padrões:
- Component composition over inheritance
- Custom hooks para lógica reutilizável
- Separation of concerns (UI/Logic/Data)
- Error boundaries para componentes
- Memoization para performance
- TypeScript-like prop validation
```

---

## 📝 **CONVENÇÕES DE CÓDIGO**

### Nomenclatura
```javascript
// ✅ CORRETO
const getUserMovies = async (userId) => {}
const MovieDetailsCard = ({ movie }) => {}
const useMovieFilters = () => {}

// ❌ INCORRETO
const getmovies = () => {}
const moviecard = () => {}
const hook1 = () => {}
```

### Estrutura de Arquivos
```
// ✅ SEMPRE organize assim:
backend/
├── app/Domain/
│   ├── Movie/
│   │   ├── Entities/
│   │   ├── ValueObjects/
│   │   ├── Services/
│   │   └── Contracts/
│   └── User/
├── app/Application/
│   ├── Movie/
│   │   ├── UseCases/
│   │   ├── DTOs/
│   │   └── Services/
├── app/Infrastructure/
│   ├── Repositories/
│   ├── ExternalServices/
│   └── Persistence/
├── app/Interface/
│   ├── Http/Controllers/Api/
│   ├── Http/Requests/
│   ├── Http/Resources/
│   └── Console/Commands/

frontend/
├── src/components/ui/
├── src/pages/
├── src/hooks/
├── src/services/
├── src/store/
└── src/utils/
```

---

## 💻 **TEMPLATES DE CÓDIGO**


### 3. React Component com Hooks
```jsx
// SEMPRE use este template para componentes React
import React, { useState, useEffect, useCallback, memo } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { fetchMovies, selectMovies, selectMoviesLoading } from '../store/movieSlice';
import { MovieCard } from '../components/ui/MovieCard';
import { LoadingSpinner } from '../components/ui/LoadingSpinner';
import { ErrorBoundary } from '../components/ui/ErrorBoundary';

const MovieList = memo(() => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const movies = useSelector(selectMovies);
  const isLoading = useSelector(selectMoviesLoading);
  
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    dispatch(fetchMovies());
  }, [dispatch]);

  const handleMovieClick = useCallback((movieId) => {
    navigate(`/movies/${movieId}`);
  }, [navigate]);

  const handleSearch = useCallback((term) => {
    setSearchTerm(term);
    // Implementar debounce aqui
  }, []);

  if (isLoading) {
    return <LoadingSpinner />;
  }

  return (
    <ErrorBoundary>
      <div className="movie-list">
        <div className="movie-grid">
          {movies.map(movie => (
            <MovieCard
              key={movie.id}
              movie={movie}
              onClick={() => handleMovieClick(movie.id)}
            />
          ))}
        </div>
      </div>
    </ErrorBoundary>
  );
});

MovieList.displayName = 'MovieList';
export default MovieList;
```

### 4. Custom Hook
```jsx
// SEMPRE crie hooks customizados para lógica complexa
import { useState, useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { movieService } from '../services/movieService';

export const useMovieOperations = () => {
  const dispatch = useDispatch();
  const { movies, loading, error } = useSelector(state => state.movies);
  
  const [operationLoading, setOperationLoading] = useState(false);

  const createMovie = useCallback(async (movieData) => {
    setOperationLoading(true);
    try {
      const newMovie = await movieService.create(movieData);
      dispatch(addMovie(newMovie));
      return { success: true, data: newMovie };
    } catch (error) {
      return { success: false, error: error.message };
    } finally {
      setOperationLoading(false);
    }
  }, [dispatch]);

  const updateMovie = useCallback(async (id, movieData) => {
    setOperationLoading(true);
    try {
      const updatedMovie = await movieService.update(id, movieData);
      dispatch(updateMovieInStore(updatedMovie));
      return { success: true, data: updatedMovie };
    } catch (error) {
      return { success: false, error: error.message };
    } finally {
      setOperationLoading(false);
    }
  }, [dispatch]);

  return {
    movies,
    loading: loading || operationLoading,
    error,
    createMovie,
    updateMovie
  };
};
```

---

## 🛡️ **REGRAS DE SEGURANÇA**

### Sempre Implementar:
```php
// ✅ Validação de entrada
public function store(MovieStoreRequest $request) {
    // Request já validado automaticamente
}

// ✅ Sanitização de dados
$cleanData = $this->sanitizeInput($request->all());

// ✅ Autorização
$this->authorize('create', Movie::class);

// ✅ Rate limiting
Route::middleware(['throttle:api'])->group(function () {
    // rotas aqui
});
```

```jsx
// ✅ Sanitização no frontend
const sanitizeInput = (input) => {
  return input.trim().replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
};

// ✅ Validação de props
MovieCard.propTypes = {
  movie: PropTypes.shape({
    id: PropTypes.number.isRequired,
    titulo: PropTypes.string.isRequired,
    ano_lancamento: PropTypes.number.isRequired
  }).isRequired
};
```

---

## 🧪 **PADRÕES DE TESTE**

### Laravel (PHPUnit)
```php
// SEMPRE crie testes seguindo este padrão
class MovieServiceTest extends TestCase
{
    use RefreshDatabase;

    private MovieService $movieService;
    private Movie $movie;

    protected function setUp(): void
    {
        parent::setUp();
        $this->movieService = app(MovieService::class);
        $this->movie = Movie::factory()->create();
    }

    /** @test */
    public function it_can_create_a_movie(): void
    {
        // Arrange
        $movieData = [
            'titulo' => 'Teste Movie',
            'ano_lancamento' => 2023,
            'genero' => 'Action',
            'sinopse' => 'Test synopsis'
        ];

        // Act
        $movie = $this->movieService->createMovie($movieData);

        // Assert
        $this->assertInstanceOf(Movie::class, $movie);
        $this->assertEquals('Teste Movie', $movie->titulo);
        $this->assertDatabaseHas('movies', ['titulo' => 'Teste Movie']);
    }
}
```

### React (Jest + React Testing Library)
```jsx
// SEMPRE teste componentes seguindo este padrão
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import MovieList from '../MovieList';
import movieReducer from '../../store/movieSlice';

const renderWithProviders = (component, initialState = {}) => {
  const store = configureStore({
    reducer: { movies: movieReducer },
    preloadedState: initialState
  });

  return render(
    <Provider store={store}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </Provider>
  );
};

describe('MovieList Component', () => {
  const mockMovies = [
    { id: 1, titulo: 'Test Movie 1', ano_lancamento: 2023 },
    { id: 2, titulo: 'Test Movie 2', ano_lancamento: 2024 }
  ];

  it('should render movies list correctly', async () => {
    // Arrange
    const initialState = {
      movies: { list: mockMovies, loading: false, error: null }
    };

    // Act
    renderWithProviders(<MovieList />, initialState);

    // Assert
    await waitFor(() => {
      expect(screen.getByText('Test Movie 1')).toBeInTheDocument();
      expect(screen.getByText('Test Movie 2')).toBeInTheDocument();
    });
  });

  it('should handle movie click navigation', async () => {
    // Implementar teste de navegação
  });
});
```

---

## ⚡ **OTIMIZAÇÕES DE PERFORMANCE**

### Backend
```php
// ✅ SEMPRE use eager loading
public function getAllMovies()
{
    return Movie::with(['user'])->paginate(15);
}

// ✅ SEMPRE implemente cache
public function getCachedMovies()
{
    return Cache::remember('movies.all', 3600, function () {
        return Movie::all();
    });
}

// ✅ SEMPRE use índices no banco
Schema::table('movies', function (Blueprint $table) {
    $table->index(['genero', 'ano_lancamento']);
});
```

### Frontend
```jsx
// ✅ SEMPRE use memo para componentes pesados
const ExpensiveMovieCard = memo(({ movie }) => {
  // componente complexo aqui
}, (prevProps, nextProps) => {
  return prevProps.movie.id === nextProps.movie.id;
});

// ✅ SEMPRE use useMemo para cálculos pesados
const filteredMovies = useMemo(() => {
  return movies.filter(movie => 
    movie.titulo.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [movies, searchTerm]);

// ✅ SEMPRE use lazy loading
const MovieDetails = lazy(() => import('./pages/MovieDetails'));
```

---

## 🔄 **PADRÕES DE ERROR HANDLING**

### Backend
```php
// ✅ SEMPRE crie exceptions específicas
class MovieNotFoundException extends Exception
{
    public function __construct(string $message = 'Filme não encontrado')
    {
        parent::__construct($message, 404);
    }
}

// ✅ SEMPRE use try-catch nos services
public function updateMovie(int $id, array $data): Movie
{
    try {
        return DB::transaction(function () use ($id, $data) {
            $movie = $this->findMovieById($id);
            return $this->movieRepository->update($movie, $data);
        });
    } catch (Exception $e) {
        Log::error('Erro ao atualizar filme: ' . $e->getMessage());
        throw new MovieUpdateException('Não foi possível atualizar o filme');
    }
}
```

### Frontend
```jsx
// ✅ SEMPRE implemente error boundaries
class MovieErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Movie Error:', error, errorInfo);
    // Enviar para serviço de monitoramento
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}

// ✅ SEMPRE trate erros em hooks
const useMovieApi = () => {
  const [error, setError] = useState(null);
  
  const handleApiCall = async (apiCall) => {
    try {
      setError(null);
      return await apiCall();
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Erro inesperado';
      setError(errorMessage);
      throw err;
    }
  };

  return { error, handleApiCall };
};
```

---

## 📊 **LOGGING E MONITORAMENTO**

```php
// ✅ SEMPRE implemente logs estruturados
Log::info('Movie created', [
    'movie_id' => $movie->id,
    'user_id' => auth()->id(),
    'title' => $movie->titulo,
    'timestamp' => now()
]);

Log::error('Movie creation failed', [
    'error' => $exception->getMessage(),
    'user_id' => auth()->id(),
    'data' => $requestData,
    'trace' => $exception->getTraceAsString()
]);
```

```jsx
// ✅ SEMPRE implemente tracking de eventos
const trackMovieAction = (action, movieId) => {
  if (process.env.NODE_ENV === 'production') {
    // analytics.track(action, { movieId, timestamp: Date.now() });
  }
};

const handleMovieCreate = async (movieData) => {
  try {
    const movie = await createMovie(movieData);
    trackMovieAction('movie_created', movie.id);
    return movie;
  } catch (error) {
    trackMovieAction('movie_create_failed', null);
    throw error;
  }
};
```

---

## 🐳 **DOCKER E DEPLOY**

```dockerfile
# ✅ SEMPRE use multi-stage builds
# Backend Dockerfile
FROM php:8.2-fpm as backend
WORKDIR /var/www
COPY composer*.json ./
RUN composer install --no-dev --optimize-autoloader
COPY . .
RUN php artisan config:cache && php artisan route:cache

# Frontend Dockerfile  
FROM node:18-alpine as frontend
WORKDIR /app
COPY package*.json ./
RUN npm ci --only-production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=frontend /app/dist /usr/share/nginx/html
```

```yaml
# ✅ SEMPRE configure healthchecks
version: '3.8'
services:
  app:
    build: ./backend
    healthcheck:
      test: ["CMD", "php", "artisan", "health:check"]
      interval: 30s
      timeout: 10s
      retries: 3
    
  frontend:
    build: ./frontend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
```

---

## 🔧 **COMANDOS ÚTEIS**

```bash
# ✅ Setup inicial do projeto
composer create-project laravel/laravel movie-api
cd movie-api
composer require tymon/jwt-auth
php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider"
php artisan jwt:secret

# ✅ Comandos de desenvolvimento
php artisan make:controller Api/MovieController --api
php artisan make:service MovieService
php artisan make:repository MovieRepository
php artisan make:request MovieStoreRequest
php artisan make:resource MovieResource

# ✅ Frontend setup
npx create-react-app movie-frontend
cd movie-frontend
npm install @reduxjs/toolkit react-redux react-router-dom axios
```

---

## 📋 **CHECKLIST DE QUALIDADE**

Antes de commitar, SEMPRE verifique:

### Backend
- [ ] Controllers apenas delegam para Services
- [ ] Services contêm toda lógica de negócio
- [ ] Repositories abstraem acesso aos dados
- [ ] Form Requests validam entrada
- [ ] Resources formatam saída da API
- [ ] Exceptions personalizadas criadas
- [ ] Logs estruturados implementados
- [ ] Testes unitários e feature criados

### Frontend
- [ ] Componentes são pequenos e focados
- [ ] Hooks customizados para lógica complexa
- [ ] Estado global gerenciado pelo Redux
- [ ] Error boundaries implementados
- [ ] Loading states em todas operações
- [ ] Memoization aplicada onde necessário
- [ ] PropTypes ou TypeScript definidos
- [ ] Testes de componente criados

### Geral
- [ ] Docker funcionando corretamente
- [ ] README atualizado
- [ ] Variáveis de ambiente documentadas
- [ ] Performance otimizada
- [ ] Segurança implementada
- [ ] Código limpo e comentado

---

**🎯 LEMBRE-SE**: Você é um desenvolvedor SÊNIOR. Seu código deve ser:
- **Limpo e legível**
- **Testável e testado**
- **Performático e otimizado**
- **Seguro e confiável**
- **Documentado e manutenível**

**Sempre pense**: "Este código será mantido por outros desenvolvedores por anos. Como posso facilitar a vida deles?"
